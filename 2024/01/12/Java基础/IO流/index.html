<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="一个简单的个人学习博客" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>IO流 |  Annie</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/annie.png" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Java基础/IO流"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  IO流
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/01/12/Java%E5%9F%BA%E7%A1%80/IO%E6%B5%81/" class="article-date">
  <time datetime="2024-01-12T13:27:35.000Z" itemprop="datePublished">2024-01-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">7.6k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">28 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p><img src="https://s2.loli.net/2024/01/15/gKf1lLWVZ6IMAbd.png" alt="IO流.png"><br>小结:<br>字节流可以复制任意文件数据，有4种方式一般采用字节缓冲流一次读写一个字节数组的方式<br>字符流只能复制文本数据，有5种方式，一般采用字符缓冲流的特有功能</p>
<h1 id="一-File"><a href="#一-File" class="headerlink" title="(一)File"></a>(一)File</h1><h2 id="1-概述和构造方法"><a href="#1-概述和构造方法" class="headerlink" title="(1)概述和构造方法"></a>(1)概述和构造方法</h2><p>File:它是<strong>文件和目录路径名</strong>的抽象表示<br>文件和目录是可以通过 File 封装成对象的<br>对于File而言，其封装的并不是一个真正存在的文件，仅仅是一个路径名而已(<strong>只是抽象路径的表示形式，并不是说这个文件一定要存在</strong>)。它可以是存在的，也可以是不存在的。<br>将来是要通过具体的操作把这个路径的内容转换为具体存在的  </p>
<p><em><strong>构造方法</strong></em></p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">File(String pathname)</td>
<td align="center">通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File实例</td>
</tr>
<tr>
<td align="center">File(String parent, String child)</td>
<td align="center">从<strong>父路径名字符串</strong>和<strong>子路径名字符串</strong>创建新的 File实例</td>
</tr>
<tr>
<td align="center">File(File parent, String child)</td>
<td align="center">从<strong>父抽象路径名</strong>和<strong>子路径名字符串</strong>创建新的File实例</td>
</tr>
</tbody></table>
<p>File f1 &#x3D; new File( pathname:”E:\itcast\java.txt”);<br>新建了一个文件夹，里面是空的，是将该目录下的java.txt文件封装成了一个对象  </p>
<p>File f2 &#x3D; new File( parent:”E:\itcast”,child:”java.txt”);</p>
<p>File f3 &#x3D; new File( pathname: “E:\itcast”);<br>File f4 &#x3D; new File(f3, child: “java,txt”);  </p>
<h2 id="2-File类的创建功能-方法"><a href="#2-File类的创建功能-方法" class="headerlink" title="(2)File类的创建功能(方法)"></a>(2)File类的创建功能(方法)</h2><p><strong>创建目录&#x2F;文件</strong>的方法</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public boolean <strong>createNewFile</strong>()</td>
<td align="left">**(创建文件)**当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件</td>
</tr>
<tr>
<td align="center">public boolean <strong>mkdir</strong>()</td>
<td align="left">**(创建单级目录)**创建由此抽象路径名命名的目录</td>
</tr>
<tr>
<td align="center">public boolean <strong>mkdirs</strong>()</td>
<td align="left">**(创建多级目录)**创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录</td>
</tr>
</tbody></table>
<p>先创建File对象，再调用方法<br>File f1 &#x3D; new File( pathname: “E:\itcast\java.txt”);<br>System.out.printIn(f1.createNewFile()); &#x2F;&#x2F;创建文件  </p>
<p><strong>注意：文件和目录的名字也不能相同，否则会创建失败</strong><br>不能同时创建一个新的目录和一个新的文件，应该创建目录再创建文件</p>
<h2 id="3-File类判断和获取功能"><a href="#3-File类判断和获取功能" class="headerlink" title="(3)File类判断和获取功能"></a>(3)File类判断和获取功能</h2><table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">public boolean isDirectory ()</td>
<td align="left">测试此抽象路径名表示的File是否为目录</td>
</tr>
<tr>
<td align="left">public boolean isFile()</td>
<td align="left">测试此抽象路径名表示的File是否为文件</td>
</tr>
<tr>
<td align="left">public boolean exists()</td>
<td align="left">测试此抽象路径名表示的File是否存在</td>
</tr>
<tr>
<td align="left">public String getAbsolutePath()</td>
<td align="left">返回此抽象路径名的绝对路径名字符串</td>
</tr>
<tr>
<td align="left">public String getPath()</td>
<td align="left">将此抽象路径名转换为路径名字符串(得到本身封装的路径)</td>
</tr>
<tr>
<td align="left">public String getName()</td>
<td align="left">返回由此抽象路径名表示的文件或目录的名称(单个)</td>
</tr>
<tr>
<td align="left">public String[] <strong>list</strong>()</td>
<td align="left">返回此抽象路径名表示的目录中的文件和目录的名称字符串数组(返回所给目录中的文件and目录名称的字符串数组)</td>
</tr>
<tr>
<td align="left">public File[] <strong>listFiles</strong>()</td>
<td align="left">返回此抽象路径名表示的目录中的文件和目录的File对象数组(返回所给目录中的文件and目录的File对象数组，全路径)</td>
</tr>
</tbody></table>
<p>listFiles()可以得到File类的对象，并调用File类的功能进行判断<br>list()只是得到字符串，不能再继续调用File的方法  </p>
<p><strong>绝对路径和相对路径的区别</strong><br><strong>绝对路径</strong>是从文件系统的根目录开始的完整路径，包括所有父文件夹的名称<br>例如：C:\Users\username\Documents\file.txt<br><strong>相对路径</strong>是相对于当前工作目录或者其他指定的基准目录的路径<br>例如：..\Documents\file.txt。相对路径不包括根目录，只是相对于当前位置的路径<br>因此，绝对路径是唯一确定文件位置的路径，而相对路径则依赖于当前位置或基准目录，可能会因为改变工作目录或基准目录而发生变化。</p>
<h2 id="4-File类删除功能"><a href="#4-File类删除功能" class="headerlink" title="(4)File类删除功能"></a>(4)File类删除功能</h2><p>public boolean delete()  删除由此抽象路径名表示的文件或目录<br>如果一个目录中有内容(目录，文件)，不能直接删除，应该先删除目录中的内容，最后才能删除目录</p>
<p><em><strong>递归遍历目录</strong></em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">//根据给定的路径创建一个File对象</span></span><br><span class="line">  <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>( pathname: <span class="string">&quot;E: litheima&quot;</span>);</span><br><span class="line">  <span class="comment">//调用方法</span></span><br><span class="line">  getAllFilePath(srcFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getAllFilePath</span><span class="params">(File srcFile)</span> &#123;</span><br><span class="line">  <span class="comment">//获取给定的File目录下所有的文件或者目录的File数组</span></span><br><span class="line">  File[] fileArray = srcFile.listFiles();</span><br><span class="line">  <span class="comment">//遍历该File数组，得到每一个File对象</span></span><br><span class="line">  <span class="keyword">if</span>(fileArray != nul1) &#123;</span><br><span class="line">    <span class="keyword">for</span>(File file : fileArray)&#123;</span><br><span class="line">    <span class="comment">//判断该File对象是否是目录</span></span><br><span class="line">    <span class="keyword">if</span>(file.isDirectory()) &#123;</span><br><span class="line">      <span class="comment">//是:递归调用</span></span><br><span class="line">      getAllFilePath(file)</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//不是:获取绝对路径输出在控制台</span></span><br><span class="line">        System.out.printIn(file.getAbsolutePath());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h1 id="二-字节流"><a href="#二-字节流" class="headerlink" title="(二)字节流"></a>(二)字节流</h1><hr>
<p><em><strong>IO流概述：</strong></em><br><img src="https://s2.loli.net/2024/01/13/DhNoWBzbM9FJHZf.png" alt="IO流理解.png"><br>输入：从硬盘上读数据到内存<br>输出：从内存将数据写到硬盘  </p>
<p><em><strong>IO流分类：</strong></em><br>按照数据的流向:<br>输入流:读数据<br>输出流:写数据<br>按照<strong>数据类型</strong>来分:<br><strong>字节流</strong>—字节输入流;字节输出流<br><strong>字符流</strong>—字符输入流;字符输出流(图片、视频、音频)(二进制)  </p>
<p>一般来说，我们说IO流的分类是按照数据类型来分的那么这两种流都在什么情况下使用呢?<br>如果数据通过Window自带的记事本软件打开，我们还可以读懂里面的内容，就使用字符流否则使用字节流。如果你不知道该使用哪种类型的流，就使用字节流</p>
<hr>
<p><strong>字节流抽象基类</strong><br>InputStream:这个抽象类是表示<strong>字节输入流</strong>的所有类的超类<br>OutputStream:这个抽象类是表示<strong>字节输出流</strong>的所有类的超类<br>子类名特点:子类名称都是以其父类名作为子类名的后缀  </p>
<h2 id="1-字节流写数据"><a href="#1-字节流写数据" class="headerlink" title="(1)字节流写数据"></a>(1)字节流写数据</h2><p><em><strong>创建字节输出流对象FileOutputStream的方式(构造方法):</strong></em><br>FileOutputStream<strong>文件输出流用于将数据写入File</strong>   </p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FileOutputStream(String name)</td>
<td align="left">创建文件输出流以指定的名称写入文件(相当于又new了一个File对象)(一般用这个更方便)</td>
</tr>
<tr>
<td align="left">FileOutputStream (File file)</td>
<td align="left">创建文件输出流以写入由指定的File对象表示的文件</td>
</tr>
<tr>
<td align="left">FileOutputStream(String name, boolean append)</td>
<td align="left">创建文件输出流以指定的名称写入文件,如果第二个参数为<strong>true则字节将写入文件的末尾而不是开头</strong></td>
</tr>
</tbody></table>
<h3 id="1-1-IO流写数据的三个步骤"><a href="#1-1-IO流写数据的三个步骤" class="headerlink" title="(1.1)IO流写数据的三个步骤"></a>(1.1)IO流写数据的三个步骤</h3><ol>
<li><strong>创建字节输出流对象</strong><br> FileOutputStream fos &#x3D; new FileOutputStream(name: “myByteStream\fos.txt”);<br> 做了三件事情:<br> A:<strong>调用系统功能创建了文件</strong><br> B:<strong>创建了字节输出流对象</strong><br> c:<strong>让字节输出流对象指向创建好的文件</strong>  </li>
<li><strong>调用字节输出流对象的写数据方法(写数据)</strong><br> fos.write(97);<br><strong>write</strong> (int b):将指定的字节写入此文件输出流  </li>
<li><strong>释放资源</strong><br> fos.close();<br>所有和IO操作相关的内容，都要释放资源：<br>void <strong>close</strong> ():①关闭此文件输出流 ②释放与此流相关联的任何系统资源(根该文件相关的系统资源都可以关闭了，我不用了)</li>
</ol>
<h3 id="1-2-IO流写数据的3种方式"><a href="#1-2-IO流写数据的3种方式" class="headerlink" title="(1.2)IO流写数据的3种方式"></a>(1.2)IO流写数据的3种方式</h3><table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">void write(int b)</td>
<td align="left">将指定的字节写入此文件输出流(一次写一个字节数据)</td>
</tr>
<tr>
<td align="left">void write(byte[] b)</td>
<td align="left">将b.length字节从指定的字节数组写入此文件输出流(一次写一个字节数组数据)</td>
</tr>
<tr>
<td align="left">void write(byte[] b, int off, int len)</td>
<td align="left">将len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流(一次写一个字节数组的部分数据)</td>
</tr>
</tbody></table>
<h3 id="1-3-字节流写数据的两个小问题"><a href="#1-3-字节流写数据的两个小问题" class="headerlink" title="(1.3)字节流写数据的两个小问题"></a>(1.3)字节流写数据的两个小问题</h3><p>(1)字节流写数据如何实现<strong>换行</strong>呢?<br>写完数据后，加换行符<br>不同系统对换行符号的识别是不一样的<br>window:\rn<br>linux:\n<br>mac:\r  </p>
<p>(2)字节流写数据如何实现<strong>追加写入</strong>呢?<br>使用FileOutputStream(String name, boolean append)<br>创建文件输出流以指定的名称写入文件,如果第二个参数为<strong>true则字节将写入文件的末尾而不是开头</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>( name: <span class="string">&quot;myByteStreamllfos,txt&quot;</span>, append: <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">  fos.write(<span class="string">&quot;he1lo&quot;</span>.getBytes());</span><br><span class="line">  fos.write(<span class="string">&quot;\r\n&quot;</span>.getBytes()); <span class="comment">//换行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-字节流写数据加异常处理"><a href="#1-4-字节流写数据加异常处理" class="headerlink" title="(1.4)字节流写数据加异常处理"></a>(1.4)字节流写数据加异常处理</h3><p><strong>finally</strong>: 在异常处理时提供 finally 块来执行所有清除操作。比如说IO流中的释放资源<br>特点:被 finally 控制的语句一定会执行，除非JVM退出<br>(Alt + Enter)  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">   可能出现异常的代码;</span><br><span class="line">  &#125;catch(异常类名 变量名)&#123;</span><br><span class="line">    异常的处理代码;</span><br><span class="line">  &#125;finally&#123;</span><br><span class="line">    执行所有清除操作;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;myByteStream\\fos.txt&quot;</span>);</span><br><span class="line">  fos.write(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(fos != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      fos.close();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复制文件的异常处理</strong><br><img src="https://s2.loli.net/2024/01/15/3dcy2InM475KmJX.png" alt="复制文件的异常处理.png"></p>
<h2 id="2-字节流读数据"><a href="#2-字节流读数据" class="headerlink" title="(2)字节流读数据"></a>(2)字节流读数据</h2><h3 id="2-1-一次读一个字节数据"><a href="#2-1-一次读一个字节数据" class="headerlink" title="(2.1)一次读一个字节数据"></a>(2.1)一次读一个字节数据</h3><p><strong>int read()</strong>:从该输入流读取一个字节的数据,如果达到文件的末尾， -1<br>需求: 把文件fos.txt中的内容读取出来在控制台输出</p>
<p>FilelnputStream:从文件系统中的文件获取输入字节<br>FilelnputStream(String name): 通过打开与实际文件的连接来创建一个FilelnputStream，该文件由文件系统中的路径名name命名  </p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">int read()</td>
<td align="left">从输入流中读取下一个字节的数据,返回实际读取的字节数量</td>
</tr>
<tr>
<td align="left">int read(byte[] b)</td>
<td align="left">从输入流中读取一定数量的字节数据到指定的字节数组中</td>
</tr>
<tr>
<td align="left">int read(byte[] b, int off, int len)</td>
<td align="left">从输入流中读取指定数量的字节数据到指定的字节数组中的指定位置</td>
</tr>
</tbody></table>
<p>使用字节输入流读数据的步骤:  </p>
<ol>
<li>创建字节输入流对象  </li>
<li>调用字节输入流对象的读数据方法  </li>
<li>释放资源</li>
</ol>
<p>字节流读数据的标准代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = new FileInputStream(&quot;myByteStream\\fos.txt&quot;);</span><br><span class="line">int by;</span><br><span class="line">while((by = fis.read()) != -1)&#123;</span><br><span class="line">  System.out.print((char)by);</span><br><span class="line">&#125;</span><br><span class="line">//释放资源</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure>

<h3 id="2-2-一次读一个字节数组数据"><a href="#2-2-一次读一个字节数组数据" class="headerlink" title="(2.2)一次读一个字节数组数据"></a>(2.2)一次读一个字节数组数据</h3><p><strong>int read(byte[] b)</strong>:从该输入流读取最多b.length个字节的数据到一个字节数组(返回的是实际读取数据的个数)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = new FileInputStream(&quot;myByteStream\\fos.txt&quot;);</span><br><span class="line">byte[] bys = new byte[1024];//1024及其整数倍</span><br><span class="line">int len;</span><br><span class="line">while ((len = fis.read(bys))!=-1)&#123;</span><br><span class="line">  System.out.print(new String(bys,0,len);</span><br><span class="line">&#125;</span><br><span class="line">//释放资源</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure>


<h2 id="3-字节缓冲流"><a href="#3-字节缓冲流" class="headerlink" title="(3)字节缓冲流"></a>(3)字节缓冲流</h2><p><strong>字节缓冲流</strong>:<br>BufferOutputStream: 该类实现缓冲输出流。通过设置这样的输出流，应用程序可以向底层输出流写入字节，而不必为写入的每个字节导致底层系统的调用<br>BuferedinputStream:创建BufferedlnputStream将创建一个内部缓冲区数组，当从流中读取或过字节时，内部冲区将根据需要从所包含的输入流中重新填充，一次很多字节  </p>
<p>FileOutputStream 每次写数据时会导致底层系统的调用，意思是每次调用FileOutputStream的写操作时，会触发底层操作系统的相关功能来进行文件写入操作。<br>这里的底层系统指的是操作系统的文件系统，它负责管理文件的读写操作。<br>因此，每次写入数据都会涉及到操作系统的文件系统调用，这也意味着写入数据的性能和效率受到操作系统的影响。<br>理解这里的底层系统意味着要意识到文件操作不仅仅是在应用程序级别进行的，还涉及到底层操作系统的支持和管理。  </p>
<table>
<thead>
<tr>
<th align="left">构造方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BufferedOutputStream(OutputStream out)</td>
<td align="left">创建一个新的缓冲输出流，以将数据写入指定的底层输出流</td>
</tr>
<tr>
<td align="left">BufferedOutputStream(OutputStream out, int size)</td>
<td align="left">创建具有指定缓冲区大小的 BufferedInputstream，并保存其参数，输入流in供以后使用</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">构造方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BufferedInputStream(InputStream in)</td>
<td align="left">创建一个 BufferedInputstream 并保存其参数，输入流in供以后使用</td>
</tr>
<tr>
<td align="left">BufferedInputStream(InputStream in, int size)</td>
<td align="left">创建一个新的缓冲输出流，以指定的缓冲区大小将数据写入指定的底层输出流</td>
</tr>
</tbody></table>
<p>为什么构造方法需要的是字节流，而不是具体的文件或者路径呢?<br>字节缓冲流<strong>仅仅提供缓冲区</strong>而真正的读写数据还得依靠基本的字节流对象进行操作</p>
<p><em><strong>缓冲区</strong></em>通过暂时存储数据来<em><strong>平衡硬盘和内存之间的速度差异</strong></em>，提高数据传输的效率的主要原因有以下几点：  </p>
<ol>
<li>缓冲区可以<strong>减少对硬盘的频繁访问</strong>：当数据被写入缓冲区后，可以先暂时存储在缓冲区中，然后在适当的时机一次性地写入硬盘。这样就减少了对硬盘的频繁访问，降低了硬盘的读写负担，提高了数据传输的效率。  </li>
<li>缓冲区可以对数据进行<strong>缓存和预读取</strong>：数据在缓冲区中可以被缓存，当需要读取相同的数据时，可以直接从缓冲区中读取，而不必再次访问硬盘。此外，缓冲区还可以预读取数据，提前将可能需要的数据加载到缓冲区中，从而减少了对硬盘的实际读取次数，提高了数据传输的效率。  </li>
<li>缓冲区可以<strong>平滑数据传输过程</strong>：数据在缓冲区中暂时存储，可以使得数据传输过程更加平滑，避免了数据传输过程中的突发性高峰，减少了传输过程中的延迟和等待时间，提高了整体的数据传输速度。<br>综上所述，通过暂时存储数据，缓冲区可以平衡硬盘和内存之间的速度差异，减少对硬盘的频繁访问，对数据进行缓存和预读取，以及平滑数据传输过程，从而提高数据传输的效率。</li>
</ol>
<p>(1)暂时存储在缓冲区中的数据可以在适当的时机一次性地写入硬盘，是因为缓冲区可以对数据进行<strong>集中管理和优化处理</strong>。<br>当数据被写入缓冲区后，操作系统或相关软件可以根据需要对缓冲区中的数据进行整理、合并或重新排序，以便在适当的时机一次性地将数据写入硬盘。这种批量写入方式可以减少对硬盘的频繁访问，提高数据传输的效率。<br>(2)另外，缓冲区传输数据并不意味着没有速度限制。缓冲区传输数据仍受到硬盘和内存的读写速度限制，但通过合理的管理和优化，缓冲区可以减少对硬盘的频繁访问，平滑数据传输过程，降低传输过程中的延迟和等待时间，从而提高整体的数据传输速度。因此，虽然缓冲区传输数据仍受到速度限制，但通过合理的设计和管理，可以提高数据传输的效率。   </p>
<p>①<strong>硬盘的读写速度</strong>受到机械运动和磁盘结构的限制，通常以每秒几十到几百兆字节的速度进行数据传输。<br>如果没有缓冲区，数据直接从硬盘传输到内存时，数据传输速度将受到硬盘读取速度的限制。<br>②<strong>内存的读写速度</strong>受到内存芯片的工作频率和总线带宽的限制，通常以每秒几千兆字节的速度进行数据传输。<br>如果没有缓冲区，数据直接从内存传输到硬盘时，数据传输速度将受到内存写入速度的限制。   </p>
<h1 id="三-字符流"><a href="#三-字符流" class="headerlink" title="(三)字符流"></a>(三)字符流</h1><p>为什么会出现字节流？  </p>
<p>由于字节流操作中文不是特别的方便，所以Java就提供字符流<br><strong>字符流 &#x3D; 字节流 + 编码表</strong><br>用字节流复制文本文件时，文本文件也会有中文，但是没有问题，原因是最终底层操作会自动进行字节拼接成中文，如何识别是中文的呢?<br>汉字在存储的时候，无论选择哪种编码存储，第一个字节都是负数  </p>
<p>一个汉字存储<br>如果是GBK编码，占用2个字节<br>如果是UTF-8编码，占用3个字节   </p>
<h2 id="编码表"><a href="#编码表" class="headerlink" title="编码表"></a>编码表</h2><p>计算机中储存的信息都是用二进制数表示的;我们在屏幕上看到的英文、汉字等字符是二进制数转换之后<br>的结果<br><strong>字符编码</strong>:就是一套自然语言的字符与二进制数之间的对应规则(A,65)  </p>
<p><strong>字符集</strong>:<br>是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等<br>计算机要准确的存储和识别各种字符集符号，就需要进行字符编码，一套字符集必然至少有一套字符编码<br>常见字符集有ASCⅡ字符集、GBXXX字符集、Unicode字符集等  </p>
<p>(1)ASCⅡ字符集<br>ASCⅡ(AmericanStandard Code for lnformation lnterchange，美国信息交换标准代码):<br>是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符(回车键、退格、换行键等)和可显示字符(英文大小写字符、阿拉伯数字和西文符号)  </p>
<p>(2)GBXXX字符集:<br><strong>GB2312</strong>:简体中文码表。一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名等都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的“全角“字符，而原来在127号以下的那些就叫“半角“字符了<br><strong>GB18030</strong>:最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等<br><strong>GBK</strong>:最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等   </p>
<p>(3)Unicode字符集:<br>为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF32。最为常用的UTF-8编码<br><strong>UTF-8编码</strong>:   可以用来表示Unicode标准中任意字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组(IETF)要求所有互联网协议都必须支持UTF-8编码。它使用-至四个字节为每个字符编码<br>编码规则:<br>128个US-ASCII字符，只需一个字节编码<br>拉丁文等字符，需要二个字节编码<br>大部分常用字(含中文)，使用三个字节编码<br>其他极少使用的Unicode辅助字符，使用四字节编码<br>(采用何种规则编码，就要采用对应规则解码，否则就会出现乱码)  </p>
<h2 id="字符串中的编码解码问题"><a href="#字符串中的编码解码问题" class="headerlink" title="字符串中的编码解码问题"></a>字符串中的编码解码问题</h2><p>编码：<br>byte[] getBytes():使用平台的默认字符集将该String编码为一系列字节，将结果存储到新的字节数组中<br>byte[] getBytes(String charsetName): 使用指定的字符集将该String编码为一系列字节，将结果存储到新的字节数组中<br>解码：<br>String(byte[] bytes):通过使用平台的默认字符集解码指定的字节数组来构造新的String<br>String(byte[] bytes,String charsetName): 通过指定的字符集解码指定的字节数组来构造新的String  </p>
<h2 id="字符流中的编码解码问题"><a href="#字符流中的编码解码问题" class="headerlink" title="字符流中的编码解码问题"></a>字符流中的编码解码问题</h2><p>字符流抽象基类:<br><strong>Reader</strong>:<strong>字符输入流</strong>的抽象类<br><strong>Writer</strong>:<strong>字符输出流</strong>的抽象类   </p>
<p>字符流中和编码解码问题相关的两个类:<br><strong>InputStreamReader</strong>:是从字节流到字符流的桥梁<br>它读取字节，并使用指定的编码将其解码为字符<br>它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集<br><strong>OutputStreamWriter</strong>:是从字符流到字节流的桥梁<br>使用指定的编码将写入的字符编码为字节<br>它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集<br><strong>(如果涉及字符流的编码和解码问题必须使用InputStreamReader和OutputStreamWriter，不能使用FileWriter和FileReader)</strong></p>
<h2 id="1-字符流写数据"><a href="#1-字符流写数据" class="headerlink" title="(1)字符流写数据"></a>(1)字符流写数据</h2><p><strong>FileWriter -&gt; OutputStreamWriter -&gt; Writer</strong>  </p>
<table>
<thead>
<tr>
<th align="left">构造方法</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">OutputStreamWriter(OutputStream out)</td>
<td align="left">创建一个使用默认字符编码的OutputStreamWriter</td>
</tr>
<tr>
<td align="left">OutputStreamWriter(OutputStream out, String charsetName)</td>
<td align="left">创建一个使用命名字符集的OutputStreamWriter</td>
</tr>
<tr>
<td align="left">OutputStreamWriter(Outputstream out,Charset cs)</td>
<td align="left">创建一个使用给定字符集的OutputStreamWriter</td>
</tr>
<tr>
<td align="left">OutputStreamWriter(OutputStream out, CharsetEncoder enc)</td>
<td align="left">创建一个使用给定字符集编码器的OutputStreamWriter</td>
</tr>
<tr>
<td align="left">(因此，命名字符集是一种通用的、标准化的字符集，而给定字符集是根据特定需求或环境定制的字符集)</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>FileWriter是用于写入字符文件的便捷类(比使用OutputStreamWriter更便捷)↓</strong></p>
<table>
<thead>
<tr>
<th align="left">构造方法</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FileWriter(String fileName)</td>
<td align="left">构造一个给定文件名的FileWriter对象</td>
</tr>
<tr>
<td align="left">FileWriter(File file)</td>
<td align="left">给一个File对象构造一个FileWriter对象</td>
</tr>
<tr>
<td align="left">FileWriter(String fileName, boolean append)</td>
<td align="left">构造一个FileWriter对象，给出一个带有布尔值的文件名，表示是否附加写入的数据</td>
</tr>
<tr>
<td align="left">FileWriter(File file, boolean append)</td>
<td align="left">给一个File对象构造一个FileWriter对象</td>
</tr>
<tr>
<td align="left">FileWriter(FileDescriptor fd)</td>
<td align="left">构造与文件描述符关联的FileWriter</td>
</tr>
</tbody></table>
<p><strong>字符流写数据的五种方式:</strong>  </p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">write(int c)</td>
<td align="left">写一个字符</td>
</tr>
<tr>
<td align="left">write(char[] cbuf)</td>
<td align="left">写入一个字符数组</td>
</tr>
<tr>
<td align="left">write(char[] cbuf, int off, int len)</td>
<td align="left">写入字符数组的一部分</td>
</tr>
<tr>
<td align="left">write(String str)</td>
<td align="left">写一个字符串</td>
</tr>
<tr>
<td align="left">write(String str, int off, int len)</td>
<td align="left">写一个字符串的一部分</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">flush</td>
<td align="left">刷新流，还可以继续写数据</td>
</tr>
<tr>
<td align="left">close</td>
<td align="left">关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据</td>
</tr>
</tbody></table>
<h2 id="2-字符流读数据"><a href="#2-字符流读数据" class="headerlink" title="(2)字符流读数据"></a>(2)字符流读数据</h2><p><strong>FileReader -&gt; InputStreamReader -&gt; Reader</strong>  </p>
<table>
<thead>
<tr>
<th align="left">构造方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">InputStreamReader(InputStream in)</td>
<td align="left">创建一个使用默认认字符集的InputStreamReader</td>
</tr>
<tr>
<td align="left">InputStreamReader(InputStream in, String charsetName)</td>
<td align="left">创建一个使用命名字符集的InputStreamReader</td>
</tr>
<tr>
<td align="left">InputStreamReader(InputStream in, Charset cs)</td>
<td align="left">创建一个使用给定字符集的InputStreamReader</td>
</tr>
<tr>
<td align="left">InputStreamReader(InputStream in, CharsetDecoder dec)</td>
<td align="left">创建一个使用给定字符集解码器的InputStreamReader</td>
</tr>
</tbody></table>
<p><strong>FileReader是用于读取字符文件的便捷类↓(比使用InputStreamReader更便捷)</strong></p>
<table>
<thead>
<tr>
<th align="left">构造方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FileReader(string fileName)</td>
<td align="left">创建一个新的 FileReader ，给定要读取的文件的名称</td>
</tr>
<tr>
<td align="left">FileReader(File file)</td>
<td align="left">创建一个新的 FileReader，给出 File读取</td>
</tr>
<tr>
<td align="left">FileReader(FileDescriptor fd)</td>
<td align="left">创建一个新的 FileReader，给予 FileDescriptor从中读取</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">int read</td>
<td align="left">一次读一个字符数据</td>
</tr>
<tr>
<td align="left">int read(char[] cbuf)</td>
<td align="left">一次读一个字符数组数据</td>
</tr>
</tbody></table>
<h2 id="3-字符缓冲流"><a href="#3-字符缓冲流" class="headerlink" title="(3)字符缓冲流"></a>(3)字符缓冲流</h2><p>BufferedWriter: 将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途。<br>BufferedReader:从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。默认值足够大，可用于大多数用途。   </p>
<p><strong>BufferedReader -&gt; Reader</strong></p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BufferedReader(Reader in)</td>
<td align="left">创建使用默认大小的输入缓冲区的缓冲字符输入流</td>
</tr>
<tr>
<td align="left">BufferedReader(Reader in, int sz)</td>
<td align="left">创建使用指定大小的输入缓冲区的缓冲字符输入流</td>
</tr>
</tbody></table>
<p>特有属性：<br>public String <strong>readLine()</strong>:读一行文字。<br>结果包含行的内容的字符串，不包括任何行终止字符(不包含换行符，返回的是内容的字符串)，如果流的结尾已经到达，则为null(没有了返回null)  </p>
<p><strong>BufferedWriter -&gt; Writer</strong></p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BufferedWriter(Writer out)</td>
<td align="left">创建使用默认大小的输出缓冲区的缓冲字符输出流</td>
</tr>
<tr>
<td align="left">BufferedWriter(Writer out, int sz)</td>
<td align="left">创建一个新的缓冲字符输出流，使用给定大小的输出缓冲区</td>
</tr>
</tbody></table>
<p>特有属性：<br>void <strong>newLine()</strong>:写一行行分隔符，行分隔符字符串由系统属性定义(换行)</p>
<h1 id="四-特殊操作流"><a href="#四-特殊操作流" class="headerlink" title="(四)特殊操作流"></a>(四)特殊操作流</h1><h2 id="1-标准输入输出流"><a href="#1-标准输入输出流" class="headerlink" title="(1)标准输入输出流"></a>(1)标准输入输出流</h2><p>System的两个成员变量<br>public final static InputStream in &#x3D; null;<br>“标准”输入流。此流已打开并准备提供输入数据。通常此流对应于键盘输入或主机环境或用户指定的其他输入源。<br>public final static PrintStream out &#x3D; null;<br>“标准”输出流。此流已打开并准备接受输出数据。通常，此流对应于显示输出或主机环境或用户指定的另一个输出目标。<br>(<strong>PrintStream</strong> -&gt; FilerOutputStream -&gt; OutputStream)  </p>
<h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><p>自己实现键盘录入数据:<br>BufferedReader br &#x3D; new BufferedReader(newlnputStreamReader(System.in));<br>写起来太麻烦，Java就提供了一个类实现键盘录入：<br>Scanner sc &#x3D; new Scanner(System.in);  </p>
<h3 id="out"><a href="#out" class="headerlink" title="out"></a>out</h3><p>输出语句的本质:是一个标准的输出流<br>PrintStream ps &#x3D; System.out;<br>PrintStream类有的方法，System.out都可以使用</p>
<p>System.out.println();<br>println有没有参数的，可以实现换行<br>print都有参数，不能空，必须有参数  </p>
<h2 id="2-打印流"><a href="#2-打印流" class="headerlink" title="(2)打印流"></a>(2)打印流</h2><p>打印流分类:<br>①字节打印流: PrintStream<br>(<strong>PrintStream</strong> -&gt; FilerOutputStream -&gt; OutputStream)<br>②字符打印流: PrintWriter<br>(<strong>PrintWriter</strong> -&gt; Writer)  </p>
<p>打印流的特点:<br><strong>只负责输出数据，不负责读取数据</strong><br>有自己的特有方法  </p>
<h3 id="①字节打印流-PrintStream"><a href="#①字节打印流-PrintStream" class="headerlink" title="①字节打印流:PrintStream"></a>①字节打印流:PrintStream</h3><p>PrintStream(StringfileName):<br>使用指定的文件名创建新的打印流使用继承父类的方法写数据，查看的时候会转码;<br>使用自己的特有方法写数据，查看的数据原样输出</p>
<h3 id="②字符打印流-PrintWriter"><a href="#②字符打印流-PrintWriter" class="headerlink" title="②字符打印流:PrintWriter"></a>②字符打印流:PrintWriter</h3><p>字符的要调用flush</p>
<p>PrintWriter (Writer out,boolean autoFlush):创建一个新的Printwriter<br>out:字符输出流<br>autoFlush:一个布尔值，如果为真，则println,printf,或format方法将刷新输出缓冲区(自动刷新)  </p>
<h2 id="3-对象序列化流"><a href="#3-对象序列化流" class="headerlink" title="(3)对象序列化流"></a>(3)对象序列化流</h2><p>对象序列化:就是将对象保存到磁盘中，或者在网络中传输对象<br><strong>(将对象写到文件中去)</strong><br>这种机制就是使用一个字节序列表示一个对象，该字节序列包含:对象的类型、对象的数据和对象中存储的属性等信息。<br>字节序列写到文件之后，相当于文件中持久保存了一个对象的信息   </p>
<p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化</p>
<p>要实现序列化和反序列化就要使用对象序列化流和对象反序列化流：<br>对象序列化流: ObjectOutputStream<br>对象反序列化流: ObjectInputStream  </p>
<h3 id="①对象序列化流-ObjectOutputStream"><a href="#①对象序列化流-ObjectOutputStream" class="headerlink" title="①对象序列化流: ObjectOutputStream"></a>①对象序列化流: ObjectOutputStream</h3><p>(ObjectOutputStream -&gt; OutputStream)  </p>
<p>①构造方法:<br><strong>ObjectOutputStream</strong>(OutputStream out): 创建一个写入指定的 OutputStream 的 ObjectOutputStream<br>②序列化对象的方法：<br><strong>writeObject</strong> (object oby)：将指定的对象写入ObjectOutputStream  </p>
<p><strong>Serializable</strong> 接口：<br>注意:<br>个对象要想被序列化，该对象所属的类必须必须实现 Serializable 接口，<br>Serializable 是一个标记接口，实现该接口，不需要重写任何方法(如果一个类实现了 Serializable 接口，则该类的对象是可以被序列化和反序列化的)</p>
<h3 id="②对象反序列化流-ObjectInputStream"><a href="#②对象反序列化流-ObjectInputStream" class="headerlink" title="②对象反序列化流: ObjectInputStream"></a>②对象反序列化流: ObjectInputStream</h3><p>将对象从文件中读取出来</p>
<p>对象反序列化流:<br>ObjectlnputStream   反序列化先前使用ObiectOutputStream编写的原始数据和对象  </p>
<p>①构造方法:<br><strong>ObjectlnputStream</strong>(InputStreamin):   创建从指定的InputStream读取的ObjectlnputStream<br>反序列化对象的方法:<br>②Object <strong>readObject</strong>(): 从ObjectlnputStream读取一个对象  </p>
<ol>
<li>用对象序列化流序列化了一个对象后，假如我们修改了对象所属的类文件，读取数据会不会出问题呢?<br>会出问题，抛出<strong>InvalidClassException</strong>异常  </li>
<li>如果出问题了，如何解决呢?<br>给对象所属的类加一个<strong>serialVersionUID</strong><br><code>private static final long serialVersionUID = 42L;</code>  </li>
<li>如果一个对象中的某个成员变量的值不想被序列化，又该如何实现呢?<br>给该成员变量加<strong>transient</strong>关键字修饰，该关键字标记的成员变量不参与序列化过程</li>
</ol>
<h2 id="4-Properties"><a href="#4-Properties" class="headerlink" title="(4)Properties"></a>(4)Properties</h2><p>Properties -&gt; Hashtable&lt; Object,Object &gt; -&gt; Dictionary&lt; K,V &gt; -&gt; Object</p>
<p>Properties是一个Map体系的集合类<br>Properties可以保存到流中或从流中加载  </p>
<p>Properties作为集合的特有方法:</p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Object setProperty(String key, String value)</td>
<td align="left">设置集合的键和值，都是String类型，底层调用Hashtable方法put</td>
</tr>
<tr>
<td align="left">String getProperty(String key)</td>
<td align="left">使用此属性列表中指定的键搜索属性(根据键获取值)</td>
</tr>
<tr>
<td align="left">Set&lt; String &gt; stringPropertyNames()</td>
<td align="left">从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串(得到键)</td>
</tr>
</tbody></table>
<p>Properties和IO流结合的方法：  </p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">void load(lnputStream inStream)</td>
<td align="left">从输入字节流读取属性列表(键和元素对)</td>
</tr>
<tr>
<td align="left">void load(Reader reader)</td>
<td align="left">从输入字符流读取属性列表(键和元素对)(把文本文件中的数据加载到Properties集合中)</td>
</tr>
<tr>
<td align="left">void store(OutputStream out, String comments)</td>
<td align="left">将此属性列表(键和元素对)写入此 Properties表中，以适合于使用load(lnputStream)方法的格式写入输出字节流</td>
</tr>
<tr>
<td align="left">void store(Writer writer, String comments)</td>
<td align="left">将此属性列表 (键和元素对)写入此 Properties表中，以适合使用 load(Reader)方法的格式写入输出字符流(集合中的数据保存到文本文件中)</td>
</tr>
</tbody></table>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://annie5281.github.io/2024/01/12/Java%E5%9F%BA%E7%A1%80/IO%E6%B5%81/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2024/01/17/Java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            多线程
          
        </div>
      </a>
    
    
      <a href="/2024/01/10/Java%E5%9F%BA%E7%A1%80/%E5%93%88%E5%B8%8C%E8%A1%A8/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">哈希表</div>
      </a>
    
  </nav>

  
   
  
    
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023-2024
        <i class="ri-heart-fill heart_icon"></i> Annie
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/annie.png" alt="Annie"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>嘿嘿 请我吃小蛋糕吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>